# -*- coding: utf-8 -*-
"""
Created on Thu Sep 17 13:48:43 2020

@author: Adrian
"""

import os
import numpy as np
import matplotlib.pyplot as plt

from tqdm import tqdm

from skimage.filters import threshold_otsu
from sklearn.linear_model import RANSACRegressor
from sklearn.metrics import r2_score

from tensorflow.keras.models import load_model

# config = tf.compat.v1.ConfigProto()
# config.gpu_options.allow_growth = True
# session = tf.compat.v1.InteractiveSession(config=config)

def evaluate_window(model, Y, size, stride=1):
    """
    Function to evaluate rotation time series of arbitrary length using the
    pretrained UNet. Predictions are made within windows of size size. For each
    data point, a final prediction is generated by averaging class probabilities 
    over all windows containing that data point.
    
    Currently, only stride 1 is implemented, making this function computationally
    costly.

    Parameters
    ----------
    model : tensorflow/keras model
        pretrained UNet model
    Y : numpy array
        angle time series
    size : int
        window length

    Returns
    -------
    label : numpy array / categorical
        predicted labels

    """
    
    Y = np.asarray(Y)
    Y = (Y-Y.mean())/(Y.max()-Y.min())
    Y = np.reshape(Y, (1,)+Y.shape+(1,))
    
    pred_dict = {i:[] for i in range(Y.shape[1])}
    
    for i in tqdm(range(0, Y.shape[1] - size + 1)):
        
        y = Y[:, i:i+size, :]
        p = model.predict(np.float16(y))
        
        for j in range(i, i+size):
            pred_dict[j].append(p[0][j-i,:])
        
    pred = np.zeros((Y.shape[1], 3))
    
    for i in pred_dict:
        pred[i, :] = np.mean(np.stack(pred_dict[i]), axis=0)
        
    label = []

    for i in range(pred.shape[0]):
        label.append(np.argmax(pred[i, :]))
        
    label = np.asarray(label)

    return label


def find_sections(X, Y, L):
    """
    Function to partition a labeled angular time series into sections corresponding
    to clockwise or counterclockwise rotations. Determines the average slope for
    each section using the RANSAC regressor for robust parameter estimation in
    noisy data.

    Parameters
    ----------
    X : numpy array
        time points
    Y : numpy array
        angle for each time point
    L : numpy array / categorical
        label / category of each time point

    Returns
    -------
    Sections : dict
        dictionary containing information on sections, keyed by section index
        'x' : numpy array
            x coordinates of all points in the section
        'y' : numpy array
            y coordinates of all points in the section
        'xf' : numpy array
            fit x coordinates
        'yf' : numpy array
            fit y coordinates
        'r2' : float
            coefficient of determination
        'nI' : int
            number of points not excluded by RANSAC (inliers)
        'dx' : float
            section length (measured in terms of number of data points)
        'dy' : float
            section total angle change
        'm' : float
            slope estimated by RANSAC
        
    """

    inds = np.where(L != 0)
    
    X, Y, L = X[inds], Y[inds], L[inds]

    dX, dY, dL = np.diff(X), np.diff(Y), np.diff(L)

    m = np.abs(dY/dX)
    m[np.isinf(m)] = np.pi
    mT = threshold_otsu(m) * 0.9
    
    sep = np.unique([0] + [len(X)-1] + list(np.where(m>mT)[0]) + list(np.where(dL != 0)[0]))
    
    RANSAC = RANSACRegressor()

    Sections = {}
    
    for i, (s1, s2) in enumerate(zip(sep[:-1], sep[1:])):
        
        if s2 - s1 <= 10:
            continue
    
        iX, iY = X[s1:s2], Y[s1:s2]
        RANSAC.fit(iX[:, np.newaxis], iY[:, np.newaxis])

        inliers = RANSAC.inlier_mask_

        xf, yf = iX[inliers, np.newaxis], RANSAC.predict(iX[inliers, np.newaxis])

        r2 = r2_score(iY[inliers], yf)

        Sections[i] = {}
        Sections[i]['x'] = iX
        Sections[i]['y'] = iY
        Sections[i]['r2'] = r2
        Sections[i]['nI'] = np.sum(inliers)
        Sections[i]['xf'] = xf
        Sections[i]['yf'] = yf
        
        Sections[i]['dy'] = iY[inliers][-1] - iY[inliers][0]
        Sections[i]['dx'] = iX[inliers][-1] - iX[inliers][0]
        Sections[i]['m'] = float(RANSAC.estimator_.coef_)      

    return Sections
