# -*- coding: utf-8 -*-
"""
Created on Thu Sep 17 13:48:43 2020

@author: Adrian
"""

import os
import pickle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import scipy.optimize as optimize

from tqdm import tqdm

from skimage.filters import threshold_otsu
from sklearn.pipeline import make_pipeline
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import RANSACRegressor
from sklearn.metrics import r2_score

from tensorflow.keras.models import load_model

# config = tf.compat.v1.ConfigProto()
# config.gpu_options.allow_growth = True
# session = tf.compat.v1.InteractiveSession(config=config)

def evaluate_window(model, Y, size, stride=1):
    """
    Function to evaluate rotation time series of arbitrary length using the
    pretrained UNet. Predictions are made within windows of size size. For each
    data point, a final prediction is generated by averaging class probabilities 
    over all windows containing that data point.
    
    Currently, only stride 1 is implemented, making this function computationally
    costly.

    Parameters
    ----------
    model : tensorflow/keras model
        pretrained UNet model
    Y : numpy array
        angle time series
    size : int
        window length

    Returns
    -------
    label : numpy array / categorical
        predicted labels

    """
    
    Y = np.asarray(Y)
    Y = (Y-Y.mean())/(Y.max()-Y.min())
    Y = np.reshape(Y, (1,)+Y.shape+(1,))
    
    pred_dict = {i:[] for i in range(Y.shape[1])}
    
    for i in tqdm(range(0, Y.shape[1] - size + 1)):
        
        y = Y[:, i:i+size, :]
        p = model.predict(np.float16(y))
        
        for j in range(i, i+size):
            pred_dict[j].append(p[0][j-i,:])
        
    pred = np.zeros((Y.shape[1], 3))
    
    for i in pred_dict:
        pred[i, :] = np.mean(np.stack(pred_dict[i]), axis=0)
        
    label = []

    for i in range(pred.shape[0]):
        label.append(np.argmax(pred[i, :]))
        
    label = np.asarray(label)

    return label


def find_sections(X, Y, L):
    """
    Function to partition a labeled angular time series into sections corresponding
    to clockwise or counterclockwise rotations. Determines the average slope for
    each section using the RANSAC regressor for robust parameter estimation in
    noisy data.

    Parameters
    ----------
    X : numpy array
        time points
    Y : numpy array
        angle for each time point
    L : numpy array / categorical
        label / category of each time point

    Returns
    -------
    Sections : dict
        dictionary containing information on sections, keyed by section index
        'x' : numpy array
            x coordinates of all points in the section
        'y' : numpy array
            y coordinates of all points in the section
        'xf' : numpy array
            fit x coordinates
        'yf' : numpy array
            fit y coordinates
        'r2' : float
            coefficient of determination
        'nI' : int
            number of points not excluded by RANSAC (inliers)
        'dx' : float
            section length (measured in terms of number of data points)
        'dy' : float
            section total angle change
        'm' : float
            slope estimated by RANSAC
        
    """

    inds = np.where(L != 0)
    
    X, Y, L = X[inds], Y[inds], L[inds]

    dX, dY, dL = np.diff(X), np.diff(Y), np.diff(L)

    m = np.abs(dY/dX)
    m[np.isinf(m)] = np.pi
    mT = threshold_otsu(m) * 0.9
    
    sep = np.unique([0] + [len(X)-1] + list(np.where(m>mT)[0]) + list(np.where(dL != 0)[0]))
    
    RANSAC = RANSACRegressor()

    Sections = {}
    
    for i, (s1, s2) in enumerate(zip(sep[:-1], sep[1:])):
        
        if s2 - s1 <= 10:
            continue
    
        iX, iY = X[s1:s2], Y[s1:s2]
        RANSAC.fit(iX[:, np.newaxis], iY[:, np.newaxis])

        inliers = RANSAC.inlier_mask_

        xf, yf = iX[inliers, np.newaxis], RANSAC.predict(iX[inliers, np.newaxis])

        r2 = r2_score(iY[inliers], yf)

        Sections[i] = {}
        Sections[i]['x'] = iX
        Sections[i]['y'] = iY
        Sections[i]['r2'] = r2
        Sections[i]['nI'] = np.sum(inliers)
        Sections[i]['xf'] = xf
        Sections[i]['yf'] = yf
        
        Sections[i]['dy'] = iY[inliers][-1] - iY[inliers][0]
        Sections[i]['dx'] = iX[inliers][-1] - iX[inliers][0]
        Sections[i]['m'] = float(RANSAC.estimator_.coef_)      

    return Sections


def get_radon(path):
    """
    Function to read radon variance datasets from a directory. Data are expected to be
    stored as one dataset per .pkl file, given as variance of the radon transform
    vs. angle: V(r).

    Parameters
    ----------
    path : string
        system path to directory containing radon data

    Returns
    -------
    radon : dict
        dict of radon data, keyed by file name

    """
        
    frames = [frame for frame in os.listdir(path) if '.pkl' in frame]
    frames = sorted(frames)
    
    radon = {}
    
    for frame in tqdm(frames):
    
        radon[frame] = pickle.load(open(os.path.join(path,frame),'rb'))

    return radon


def nextpow2(x):
    return 1<<(x-1).bit_length()


def get_modes(x, y, nM, nF):
    """
    Function to obtain cosine modes from a single data set (x, y) via Fourier
    transformation.

    Mode numbers are F[inds], mode powers are T[inds].

    Parameters
    ----------
    x : numpy array
        data x coordinates --UNUSED--
    y : numpy array
        data y coordinates
    nM : int
        number of modes
    nF : int
        controls zero-padding (smoothes out the fft)

    Returns
    -------
    F : numpy array
        spectrum frequencies
    T : numpy array
        fourier spectrum
    inds : numpy array
        mode indices

    """
    
    inds = (4*np.arange(1,nM+1))*nF

    dn = nextpow2(nF*len(y))-len(y)
    ln = np.floor(dn/2)
    rn = np.ceil(dn/2)
    
    yp = np.pad(y,(int(ln), int(rn)), mode='constant', constant_values=0)
    
    T = np.fft.rfft(yp,2*len(yp))
    F = np.fft.rfftfreq(2*(dn + len(y)),d=2*np.pi/len(y))
    
    return F, T, inds


def ifft_modes(F, T, inds, nS, nF):

    dn = nextpow2(nF*nS)-nS
    ln = np.floor(dn/2)

    I = np.arange(len(F))
    I[inds] = 0
    I = I[I!=0]
    
    iT = T.copy()
    
    np.put(iT,I,0)

    iy = np.fft.irfft(iT,2*nS*nF)
    iy = iy[:nF*nS]
    iy = iy[int(ln):int(ln)+nS]
    
    return iy, iT


def get_radon_modes(radon, nF=512, nM=128):
    """
    Function to decompose a series of radon variance data sets V(r) into
    cosine modes.

    Parameters
    ----------
    radon : dict
        dict of radon data
    nM : int, optional
        number of modes; the default is 128
    nF : int, optional
        controls zero-padding (smoothes out the fft); the default is 512

    Returns
    -------
    locs : numpy array
        mode numbers
    fourier : numpy array
        mode power
    frequencies : numpy array
        mode frequecies

    """
    
    frames = list(radon.keys())
    frames = sorted(frames)
    
    
    nR = len(radon[frames[0]])
    n = len(frames)
    
    theta = np.linspace(0,2*np.pi,2*nR)

    fourier = {}

    for i, frame in tqdm(enumerate(frames), total=n):
        
        rho = np.concatenate([radon[frame], radon[frame]])

        rho -= rho.mean()
        rho /= np.abs(rho).std()
        
        F, T, inds = get_modes(theta, rho, nM, nF)
        
        P = np.abs(T[inds])
        
        fourier[frame] = P
        
    frequencies = F[inds]
                    
    return inds/nF, fourier, frequencies


def embed_radon(modes, fourier, n):

    PipelineP = make_pipeline(PCA(n_components=n))
    
    data = {}
    for i, m in enumerate(modes):
        data[m] = []
        for frame in fourier:
            data[m].append(fourier[frame][i])
            
    data = pd.DataFrame(data)
    pos = PipelineP.fit_transform(data)

    return pos


def radon_cluster_modes(modes, fourier, n=4):
    """
    Function to perform k-means clustering of cosine modes.

    Parameters
    ----------
    modes : numpy array
        mode numbers
    fourier : numpy array
        mode powers
    n : int, optional
        number of clusters; the default is 6

    Returns
    -------
    C : numpy array
        cluster assignment

    """
    
    PipelineC = make_pipeline(KMeans(n_clusters=n))
    
    data = {}
    for i, m in enumerate(modes):
        data[m] = []
        for frame in fourier:
            data[m].append(fourier[frame][i])
            
    data = pd.DataFrame(data)
    
    C = PipelineC.fit_predict(data)
    
    return C


def radon_fit_ellipses(radon):
    """
    Function to fit radon variance data sets with ellipses in polar coordinates.

    Parameters
    ----------
    radon : dict
        dict of radon data

    Returns
    -------
    a : numpy array
        first axis
    b : numpy array
        second axis
    theta0 : numpy array
        orientation of first axis, [0, pi] due to symmetry
    R2 : numpy array
        coefficient of determination

    """
    
    frames = list(radon.keys())
    frames = sorted(frames)  
    
    nR = len(radon[frames[0]])
    n = len(frames)    

    theta = np.linspace(0,2*np.pi,2*nR)
    
    a, b, theta0, R2 = np.zeros(n), np.zeros(n), np.zeros(n), np.zeros(n)
    
    for i, frame in tqdm(enumerate(frames), total=n):
        
        rho = np.concatenate([radon[frame], radon[frame]])
        a[i], b[i], theta0[i], R2[i] = fit_ellipse_polar_centered(theta, rho)
        
        rho -= rho.mean()
        rho /= np.abs(rho).std()       
        
    theta0[theta0 < 0] = theta0[theta0 < 0] + np.pi
    theta0[theta0 > np.pi] = theta0[theta0 > np.pi] - np.pi
    
    return a, b, theta0, R2


def fit_ellipse_polar_centered(Theta, Rho):
    """
    Function to fit an allipse to data in polar coordinates.

    Parameters
    ----------
    Theta : numpy array
        angle
    Rho : numpy array
        radius

    Returns
    -------
    a : float
        first axis length
    b : float
        second axis length
    dT : float
        orientation of the first axis
    R2 : float
        coefficient of determination

    """

    def fit_fun(p):
        a, b, dT = p
        Rhoc = a*b/np.sqrt(b**2*np.cos(Theta - dT)**2+a**2*np.sin(Theta - dT)**2)
        return np.sum((Rhoc-Rho)**2)/np.sum((Rho-np.mean(Rho))**2)
    
    p = [np.max(Rho), np.min(Rho), Theta[np.argmax(Rho)]]
    
    fit_obj = optimize.minimize(fit_fun,p,method='TNC',bounds=[(0, None),(0, None),(0,2*np.pi)])
    
    R2 = 1-fit_obj.fun
    a, b, dT = fit_obj.x
    
    if b > a:
        a, b = b, a
        dT = dT - np.pi/2
    
    return a, b, dT, R2


def ellipse_coords_polar_centered(Theta,a,b):
    """
    Function to compute ellipse radial coordinates in polar coordinates.

    Parameters
    ----------
    Theta : numpy array
        angle
    a : float
        first axis length
    b : float
        second axis length

    Returns
    -------
    Rho : numpy array
        radius

    """
    
    Rho = a*b/np.sqrt(b**2*np.cos(Theta)**2+a**2*np.sin(Theta)**2)
    return Rho
        

def sort_clusters_by_ratio(a, b, C):
    """
    Function to reassign clusters based on sorting by ellipse aspect ratio (a-b)/a.

    Parameters
    ----------
    a : numpy array
        first axis lengths
    b : numpy array
        second axis lengths
    C : numpy array
        cluster assignments

    Returns
    -------
    E : numpy array
        ellipse aspect ratio
    C : numpy array
        sorted cluster assignment

    """
    
    L = np.unique(C)
    
    E = np.zeros(len(a))
    for i, (ai, bi) in enumerate(zip(a, b)):
        E[i] = (max([ai, bi])-min([ai, bi]))/max([ai, bi])

    EC = [np.mean(E[C==c]) for c in L]
    CN = np.zeros(len(C))
    
    for l in L:
        I = C == L[np.argmax(EC)]
        EC[np.argmax(EC)] = -1
        CN[I] = l
    C = CN
    
    return E, C


if __name__ == '__main__':
    
    Path = './radon_samples'
    
    radon = get_radon(Path)
    a, b, theta0, R2 = radon_fit_ellipses(radon)
    modes, fourier, frequencies = get_radon_modes(radon)
    cluster = radon_cluster_modes(modes, fourier, 4)
    pos = embed_radon(modes, fourier, 2)
    ratio, cluster = sort_clusters_by_ratio(a, b, cluster)
    
    
    X, Y = np.arange(len(theta0)), theta0
    
    model = load_model('./DL_denoise_model_4096.h5')
    
    L = evaluate_window(model, Y, 4096)
    sections = find_sections(X, Y, L)
    
    plt.figure(figsize=plt.figaspect(.75/(2*1.618)))
    plt.scatter(X[L==0], Y[L==0], s=1, c='gray', alpha = 0.5)
    plt.scatter(X[L==1], Y[L==1], s=1, c='r')
    plt.scatter(X[L==2], Y[L==2], s=1, c='b')
    plt.xlabel('time (s)', fontsize=16)
    plt.ylabel('angle (rad)', fontsize=16)
    plt.title('synthetic data (labels recovered)', fontsize=16)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    plt.tight_layout()
    
    plt.figure(figsize=plt.figaspect(.75/(2*1.618)))
    plt.scatter(X[L==0], Y[L==0], s=1, c='gray', alpha = 0.5)
    plt.scatter(X[L==1], Y[L==1], s=1, c='r')
    plt.scatter(X[L==2], Y[L==2], s=1, c='b')
    
    for i, section in sections.items():
        plt.plot(section['xf'], section['yf'], 'k--')
    
    plt.xlabel('time (s)', fontsize=16)
    plt.ylabel('angle (rad)', fontsize=16)
    plt.title('synthetic data (with fits)', fontsize=16)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    plt.tight_layout()